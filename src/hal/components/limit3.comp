component limit3 "Limit the output signal to fall between min and max, limit its slew rate to less than maxv per second, and limit its second derivative to less than maxa per second squared.  When the signal is a position, this means that the position, velocity, and acceleration are limited.";
pin in float in;
pin out float out;
pin in bit load "When TRUE, immediately set \\fBout\\fB to \\fBin\\fR, ignoring maxv and maxa";
pin in float min_=-1e20;
pin in float max_=1e20;
pin in float maxv=1e20;
pin in float maxa=1e20;
//pin out float debug1;
//pin out float debug2;
//pin out u32 debug3;
variable double in_old;
variable double out_old;
variable double out_vel;
function _;
license "GPL";
;;

#include "rtapi_math.h"

#define SET_NEXT_STATE(out_pos)				\
    do {						\
	/*debug1 = a;*/					\
	/*debug2 = t;*/					\
	/*debug3 = reason;*/				\
	out_old = out;					\
	out = out_pos;					\
	in_old = in;					\
	return;						\
    } while (0)

#define VALID_NEXT(pos) ((pos) <= max_pos && (pos) >= min_pos)

// Distance = avg. velocity * time
#define S_GIVEN_VI_VF_T(vi,vf,t) ((vf + vi)/2 * t)
// Time = chg. velocity / acceleration
#define T_GIVEN_VI_VF_A(vi,vf,a) (fabs((vf - vi) / a))
// Final velocity = initial velocity + acceleration * time
#define VF_GIVEN_VI_A_T(vi,a,t) (vi + a*t)

FUNCTION(_) {
    double in_pos_lim, in_vel, min_vel, max_vel, min_pos, max_pos;
    double stop_pos_max, stop_pos_min, stop_time_max, stop_time_min;
    double vel_match_time, vel_match_in_pos, vel_match_out_pos;
    int out_dir_rel;
    double a, v, s, t;
    int reason = 0; // Used for debugging

    if (load) {
	// Apply first order limit
	in_pos_lim = fmin(max_, fmax(min_, in));
	SET_NEXT_STATE(in_pos_lim);
	return;
    }

    // Input velocity
    in_vel = (in - in_old) / fperiod;
    // Output velocity:  v_cur = 2 * v_avg - v_prev
    // - FIXME:  why does this appear to lag by a cycle?
    out_vel = 2 * (out-out_old)/fperiod - out_vel;
    // Most negative/positive velocity reachable in one period
    // - vf = vi + a * t
    min_vel = fmax(VF_GIVEN_VI_A_T(out_vel, -maxa, fperiod), -maxv);
    max_vel = fmin(VF_GIVEN_VI_A_T(out_vel,  maxa, fperiod),  maxv);
    // Most negative/positive position reachable in one period
    // - cur. pos + (distance to reach min/max vel in one period)
    min_pos = out + S_GIVEN_VI_VF_T(out_vel, min_vel, fperiod);
    max_pos = out + S_GIVEN_VI_VF_T(out_vel, max_vel, fperiod);

    // Direction of output movement relative to input movement
    out_dir_rel = (out_vel - in_vel < 0) ? -1 : 1;

    // Calculate shortest distance to stop after next step
    stop_time_max = T_GIVEN_VI_VF_A(  // - time to decel from max_vel to 0
	max_vel, 0.0, -maxa);
    stop_pos_max = max_pos            // - distance to stop from max_pos
	+ S_GIVEN_VI_VF_T(max_vel, 0.0, stop_time_max);
    stop_time_min = T_GIVEN_VI_VF_A(  // - time to decel from min_vel to 0
	min_vel, 0.0, -maxa);
    stop_pos_min = min_pos            // - distance to stop from min_pos
	+ S_GIVEN_VI_VF_T(min_vel, 0.0, stop_time_min);

    // Follow input signal:  match position and velocity
    // - min time for velocity match
    vel_match_time = fabs(out_vel-in_vel) / maxa;
    // - input position after velocity match
    vel_match_in_pos = in + in_vel * vel_match_time;
    // - output position after velocity match
    vel_match_out_pos = out
	+ out_vel * (vel_match_time+fperiod)
	+ 0.5 * (-out_dir_rel * maxa) * pow(vel_match_time,2);

    // Goal:  head toward and stop at min position limit when:
    // - Input signal is headed below min limit
    // - Input signal is below min limit & headed back, but too early to chase
    // - Output signal is moving toward min position limit and may overshoot
    reason = 1000;
    if ((vel_match_in_pos < min_)
	|| (in <= min_ && vel_match_in_pos < vel_match_out_pos)
	|| (stop_pos_min <= min_ && !VALID_NEXT(min_))) {
	reason += 100;
	t = 2 * (min_-out) / (out_vel + 0); // t:  time to decel to stop on lim
	// Decide what to do, most urgent to least
	if (VALID_NEXT(min_) && t < fperiod)
	    // This period:  stop & lock on limit will stay within constraints
	    SET_NEXT_STATE(min_);
	reason += 100;
	if (stop_time_max < fperiod) {
	    // <= two periods:  finesse acceleration for a greased landing
	    a = (0-out_vel)/t;             // a:  accel to decel to stop on lim
	    v = out_vel + a * fperiod;     // v:  vel after accel a for 1 per.
	    s = (v + out_vel)/2 * fperiod; // s:  dist after accel a for 1 per.
	    SET_NEXT_STATE(out + s);
	}
	reason += 100;
	if (stop_pos_min <= min_ && !VALID_NEXT(min_))
	    // N periods:  in danger of overshoot; maximum deceleration
	    SET_NEXT_STATE(max_pos);
	reason += 100;
	// No urgent timing:  maximum acceleration
	SET_NEXT_STATE(min_pos);
    }
    reason = 2000;
    if ((vel_match_in_pos > max_)                     // Input above max limit
	|| (in >= max_ && vel_match_in_pos > vel_match_out_pos)
	|| (stop_pos_max >= max_ && !VALID_NEXT(max_))) {
	reason += 100;
	t = 2 * (max_-out) / (out_vel + 0); // t:  time to decel to stop on lim
	// Decide what to do, most urgent to least
	if (VALID_NEXT(max_) && t < fperiod)
	    // This period:  stop & lock on limit will stay within constraints
	    SET_NEXT_STATE(max_);
	reason += 100;
	if (stop_time_min < fperiod) {
	    // <= two periods:  finesse acceleration for a greased landing
	    a = (0-out_vel)/t;             // a:  accel to decel to stop on lim
	    v = out_vel + a * fperiod;     // v:  vel after accel a for 1 per.
	    s = (v + out_vel)/2 * fperiod; // s:  dist after accel a for 1 per.
	    SET_NEXT_STATE(s + out);
	}
	reason += 100;
	if (stop_pos_max >= max_ && !VALID_NEXT(max_))
	    // N periods:  in danger of overshoot; maximum deceleration
	    SET_NEXT_STATE(min_pos);
	reason += 100;
	// No urgent timing:  maximum acceleration
	SET_NEXT_STATE(max_pos);
    }

    // Follow input signal
    //
    reason = 3000;
    // - Try to track input
    reason += 100;
    if (VALID_NEXT(in))
	SET_NEXT_STATE(in);
    // - Try to match position and velocity without overshooting
    if (out > in) {                                   // Output > input:
	reason += 100;
	if (vel_match_in_pos < vel_match_out_pos)     // - Not overshooting
	    SET_NEXT_STATE(min_pos);                  //   - Move closer
	else                                          // - Overshooting
	    SET_NEXT_STATE(max_pos);                  //   - Back off
    } else {                                          // Output <= input
	reason += 200;
	if (vel_match_in_pos > vel_match_out_pos)     // - Not overshooting
	    SET_NEXT_STATE(max_pos);                  //   - Move closer
	else                                          // - Overshooting
	    SET_NEXT_STATE(min_pos);                  //   - Back off
    }

    // Shouldn't get here
    reason = 4000;
    SET_NEXT_STATE((max_pos-min_pos)/2);
}
