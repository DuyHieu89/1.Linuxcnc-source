component raster "Outputs laser power based upon pre programmed rastering data";
pin in float position "input coordinate for raster";
pin in bit   reset    "resets the component";
pin in port  program     "pixel data used by the raster";
pin in bit   run      "starts the raster";

pin out bit enabled = 0      "When a valid raster program is running.";
pin out float output = -1    "current output level command";
pin out bit fault = 0        "If error has occured";
pin out unsigned fault_code = 0 "Code of fault";
pin out unsigned state = 0   "current state";
pin out float program_position "base position of program at run start";
pin out float program_offset  "offset to start of pixel data";
pin out unsigned bpp         "bits per pixel.";
pin out float ppu            "points per unit";
pin out unsigned count       "pixel count";
pin out float bitmap_position "calculated position in bitmap";
pin out float current_pixel_value "current loaded pixel value";
pin out float previous_pixel_value "previously loaded pixel value";
pin out signed current_pixel_index "currently loaded pixel index";

function _;
license "GPL";

include <rtapi_math.h>;
include <stdlib.h>;

;;



#define MAX_PROGRAM_SIZE 50000

enum {
    ERROR_NONE          = 0,  //no error at the moment
    ERROR_BEGIN         = 1,  //begin statement was malformed
    ERROR_INVALIDBPP    = 2,  //bpp must be between 4-32 and divisable by 4
    ERROR_INVALIDPPU    = 3,  //ppu must be greater than 0
    ERROR_BADPIXELDATA  = 4,  //pixel data does not match begin statement
    ERROR_PROGTOOBIG    = 5,  //the requested raster program will be too big
    ERROR_PROGTOOSMALL  = 6,  //the requested raster program will be too small. It must have more than 1 programmed point
    ERROR_WRONGDIR      = 7   //the raster position was run in the wrong position
} raster_error;

typedef enum {
    FAULT = 0, 
    IDLE =  1,  
    RUN   = 2
} raster_state;

bool read_float(hal_port_t port, hal_float_t* value) {
    char data[32];
    unsigned int available = hal_port_readable(port);
    char* pos;

    hal_port_peek(port, data, available < 32 ? available : 32);

    pos = strchr(data, ';');

    if(!pos) {
        return false;
    }

    *value = strtod(data, &pos);

    if(pos == data) {
        return false;
    }

    hal_port_peek_commit(port, pos - data + 1);

    return true;
}

bool read_uint(hal_port_t port, hal_u32_t* value) {
    char data[10];
    unsigned int available = hal_port_readable(port);
    char* pos;

    hal_port_peek(port, data, available < 10 ? available : 10);

    pos = strchr(data, ';');

    if(!pos) {
        return false;
    }

    *value = strtoul(data, &pos, 10);
    
    if(pos == data) {
        return false;
    }

    hal_port_peek_commit(port, pos - data + 1);

    return true;
}

bool read_program_begin(hal_port_t port, hal_float_t* offset, hal_u32_t* bits_per_pixel, hal_float_t* pixels_per_unit, hal_u32_t* total_pixel_count) {
    if(!read_float(port, offset)) {
        return false;
    }

    if(!read_uint(port, bits_per_pixel)) {
        return false;
    }

    if(!read_float(port, pixels_per_unit)) {
        return false;
    }

    if(!read_uint(port, total_pixel_count)) {
        return false;
    }

    return true;
}


/*
    reads and consumes a pixel value for the program port. 
    pixel data is encoded as ascii hex values [0-9][A-F] with each character representing 4 bits of data
    pixels bpp must be defined in increments of 4.
*/
bool read_pixel_data(hal_port_t port, unsigned bits_per_pixel, hal_float_t* power) {
    char data[8];
    unsigned int value = 0;
    unsigned int off = 0xFFFFFFFF >> (32 - bits_per_pixel);
    unsigned int max = off - 1;
    unsigned int bytes_per_pixel = bits_per_pixel / 4;
    char* pos;

    if(!hal_port_read(port, data, bytes_per_pixel)) {
        return false;
    }

    data[bytes_per_pixel] = 0;

    value = strtoul(data, &pos, 16);

    if(data == pos) {
        return false;
    }
    
    /*a value with all 1 bits in the pixel is a special value considered "off" for the raster and no power will be output*/
    if(value == off) {
        *power = -1.0;
    } else {
        *power = 100.0 * ((hal_float_t)value)/((hal_float_t)(max));
    }

    return true;
}

FUNCTION(_) { 
    static hal_float_t previous_bitmap_position;
    hal_float_t fraction;

    output = -1.0;
    enabled = 0;

    if (reset) {
        state = IDLE;
        hal_port_clear(program);
    } else if (state == FAULT) {
        fault = 1;
    } else if (state == IDLE) {
        fault = 0;
        fault_code = ERROR_NONE;
        bitmap_position = 0.0;
        current_pixel_value = -1.0;
        previous_pixel_value = -1.0;
        current_pixel_index = -1.0;        

        if(run) {
            if(!read_program_begin(program, &program_offset, &bpp, &ppu, &count)) {
                fault = 1;
                fault_code = ERROR_BEGIN;
            } else if((bpp == 0) || (bpp > 32) || ((bpp % 4) != 0)) {
                fault = 1;
                fault_code = ERROR_INVALIDBPP;
            } else if(ppu <= 0.0) {
                fault = 1;
                fault_code = ERROR_INVALIDPPU;
            } else if(hal_port_readable(program) != ((bpp / 4) * count)) {
                fault = 1;
                fault_code = ERROR_BADPIXELDATA;
            } else {
                state = RUN;
                program_position = position;
                bitmap_position = (position - (program_position + program_offset)) * ppu * (program_offset < 0.0 ? -1.0: 1.0);
                previous_bitmap_position = bitmap_position;
              }
        }       
    } else if (state == RUN) {
        bitmap_position = (position - (program_position + program_offset)) * ppu * (program_offset < 0.0 ? -1.0 : 1.0);

        if(!run) {
            state = IDLE;
            hal_port_clear(program);
        } else if(bitmap_position < previous_bitmap_position) {
            state = FAULT;
            fault_code = ERROR_WRONGDIR;
        } else {
            previous_bitmap_position = bitmap_position;
            enabled = 1;

            while((bitmap_position < count) && (bitmap_position > current_pixel_index)) {
                current_pixel_index = current_pixel_index+1;
                previous_pixel_value = current_pixel_value;

                if(!read_pixel_data(program, bpp, &current_pixel_value)) {
                    state = FAULT;
                    fault_code = ERROR_PROGTOOSMALL;
                    return;
                }
            }
        
            if((current_pixel_value > 0.0) || (previous_pixel_value > 0.0)) {
                fraction = bitmap_position - (hal_float_t)(current_pixel_index - 1); 
                output = fraction*(current_pixel_value-previous_pixel_value) + previous_pixel_value;
            }
        }
    }
}

