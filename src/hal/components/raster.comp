component raster "Outputs laser power based upon pre programmed rastering data";
pin in float position "input coordinate for raster";
pin in bit   reset    "resets the component";
pin in port  program     "pixel data used by the raster";
pin in bit   run      "starts the raster";

pin out bit enabled = 0      "When a valid raster program is running.";
pin out float output = -1    "current output level command";
pin out bit fault = 0        "If error has occured";
pin out unsigned fault_code = 0 "Code of fault";
pin out unsigned state = 0    "current state";
pin out float program_position = 0.0 "base position of program at run start";
pin out float program_offset = 0.0  "offset to start of pixel data";
pin out unsigned bpp = 0         "bits per pixel.";
pin out float ppu = 0.0            "points per unit";
pin out unsigned count = 0       "pixel count";
pin out float bitmap_position = 0.0 "calculated position in bitmap";
pin out float current_pixel_value = -1.0 "current loaded pixel value";
pin out float previous_pixel_value = -1.0 "previously loaded pixel value";
pin out signed current_pixel_index = -1 "currently loaded pixel index";

function _;
license "GPL";

include <rtapi_math.h>;
include <stdlib.h>;

;;



#define MAX_PROGRAM_SIZE 50000

enum {
    ERROR_NONE           = 0, //no error at the moment
    ERROR_INVALID_OFFSET = 1, //offset must be a float
    ERROR_INVALID_BPP    = 2, //bpp must be between 4-32 and divisable by 4
    ERROR_INVALID_PPU    = 3, //ppu must be greater than 0
    ERROR_INVALID_COUNT  = 4, //count must be a float > 0
    ERROR_BADPIXELDATA   = 5, //pixel data does not match begin statement
    ERROR_PROGWRONGSIZE  = 6, //requested raster program doesn't match count
    ERROR_WRONGDIR       = 7  //the raster position was run in the wrong direction
} raster_error;

typedef enum {
    IDLE =  0, 
    RUN =  1,  
    FAULT  = 2
} raster_state;

bool read_float(hal_port_t port, hal_float_t* value) {
    char data[32];
    unsigned int available = hal_port_readable(port);
    char* pos;

    hal_port_peek(port, data, available < 32 ? available : 32);

    pos = strchr(data, ';');

    if(!pos) {
        return false;
    }

    *value = strtod(data, &pos);

    if(pos == data) {
        return false;
    }

    hal_port_peek_commit(port, pos - data + 1);

    return true;
}

bool read_uint(hal_port_t port, hal_u32_t* value) {
    char data[10];
    long val;
    unsigned int available = hal_port_readable(port);
    char* pos;

    hal_port_peek(port, data, available < 10 ? available : 10);

    pos = strchr(data, ';');

    if(!pos) {
        return false;
    }

    val = strtoul(data, &pos, 10);
    
    if(pos == data) {
        return false;
    }

    if(val < 0) {
        return false;
    }

    *value = val;

    hal_port_peek_commit(port, pos - data + 1);

    return true;
}


/*
    reads and consumes a pixel value for the program port. 
    pixel data is encoded as ascii hex values [0-9][A-F] with each character representing 4 bits of data
    pixels bpp must be defined in increments of 4.
*/
bool read_pixel_data(hal_port_t port, unsigned bits_per_pixel, hal_float_t* power) {
    char data[8];
    long value = 0;
    unsigned int off = 0xFFFFFFFF >> (32 - bits_per_pixel);
    unsigned int max = off - 1;
    unsigned int bytes_per_pixel = bits_per_pixel / 4;
    char* pos;

    if(!hal_port_read(port, data, bytes_per_pixel)) {
        return false;
    }

    data[bytes_per_pixel] = 0;

    value = strtol(data, &pos, 16);

    if(data == pos) {
        return false;
    }

    if(value < 0) {
        return false;
    }
    
    /*a value with all 1 bits in the pixel is a special value considered "off" for the raster and no power will be output*/
    if(value == off) {
        *power = -1.0;
    } else {
        *power = 100.0 * ((hal_float_t)value)/((hal_float_t)(max));
    }

    return true;
}

FUNCTION(_) { 
    static hal_float_t previous_bitmap_position;
    hal_float_t fraction;

    output = -1.0;
    enabled = 0;

    if (reset) {
        state = IDLE;
        fault = 0;
        fault_code = ERROR_NONE;
        hal_port_clear(program);
    } else if (state == FAULT) {
        fault = 1;
    } else if (state == IDLE) {
        bitmap_position = 0.0;
        current_pixel_value = -1.0;
        previous_pixel_value = -1.0;
        current_pixel_index = -1.0;        

        if(run) {
            if(!read_float(program, &program_offset)) {
                state = FAULT;
                fault_code = ERROR_INVALID_OFFSET;
            } else if(!read_uint(program, &bpp) || (bpp == 0) || (bpp > 32) || ((bpp % 4) != 0)) {
                state = FAULT;
                fault_code = ERROR_INVALID_BPP;
            } else if(!read_float(program, &ppu) || (ppu <= 0.0)) {
                state = FAULT;
                fault_code = ERROR_INVALID_PPU;
            } else if(!read_uint(program, &count) || (count < 2)) {
                state = FAULT;
                fault_code = ERROR_INVALID_COUNT;
            } else if(hal_port_readable(program) != ((bpp / 4) * count)) {
                state = FAULT;
                fault_code = ERROR_PROGWRONGSIZE;
            } else {
                state = RUN;
                program_position = position;
                bitmap_position = (position - (program_position + program_offset)) * ppu * (program_offset < 0.0 ? -1.0: 1.0);
                previous_bitmap_position = bitmap_position;
              }
        }       
    } else if (state == RUN) {
        bitmap_position = (position - (program_position + program_offset)) * ppu * (program_offset < 0.0 ? -1.0 : 1.0);

        if(!run) {
            state = IDLE;
            hal_port_clear(program);
        } else if(bitmap_position < previous_bitmap_position) {
            state = FAULT;
            fault_code = ERROR_WRONGDIR;
        } else {
            previous_bitmap_position = bitmap_position;
            enabled = 1;

            while((bitmap_position < count) && (bitmap_position > current_pixel_index)) {
                current_pixel_index = current_pixel_index+1;
                previous_pixel_value = current_pixel_value;

                if(!read_pixel_data(program, bpp, &current_pixel_value)) {
                    state = FAULT;
                    fault_code = ERROR_BADPIXELDATA;
                    return;
                }
            }
        
            if((current_pixel_value > 0.0) || (previous_pixel_value > 0.0)) {
                fraction = bitmap_position - (hal_float_t)(current_pixel_index - 1); 
                output = fraction*(current_pixel_value-previous_pixel_value) + previous_pixel_value;
            }
        }
    }
}

