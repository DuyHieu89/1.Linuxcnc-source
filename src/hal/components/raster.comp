component raster "Outputs laser power based upon pre programmed rastering data";
pin in float position "input coordinate for raster program";
pin in bit   reset    "resets the component";
pin in port  program  "port used to program the raster";

pin out bit enabled = 0      "When a valid raster program is running.";
pin out float output = -1    "current output level command";
pin out bit fault = 0        "If error has occured";
pin out unsigned fault_code = 0 "Code of fault";
pin out float program_position "position at time of program begin";
pin out float program_offset "offset from program_position that pixel data starts at";
pin out unsigned state = 0   "current state";
pin out unsigned bpp = 0     "bits per pixel";
pin out float ppu    "pixels per unit";
pin out float bitmap_position "calculated position in bitmap";
pin out float current_pixel_value "current loaded pixel value";
pin out float previous_pixel_value "previously loaded pixel value";
pin out signed current_pixel_index "currently loaded pixel index";
pin out unsigned pixel_count "total program pixel count";

function _;
license "GPL";

include <rtapi_math.h>;
include <stdlib.h>;

;;



#define MAX_PROGRAM_SIZE 50000

enum {
    ERROR_NONE          = 0,  //no error at the moment
    ERROR_INVALID_CMD   = 1,  //an invalid command was issued 
    ERROR_PROGTOOBIG    = 2,  //the requested raster program will be too big
    ERROR_PROGTOOSMALL  = 3,  //the requested raster program will be too small. It must have more than 1 programmed point
    ERROR_WRONGDIR = 4
} raster_error;

typedef enum { 
    PROGRAM_CLEAR = 0, 
    PROGRAM_FAULT = 1, 
    PROGRAM_BEGIN = 2,
    PROGRAM_RUN   = 5 
} raster_state;


bool read_float(hal_port_t port, hal_float_t* value) {
    char data[32];
    unsigned int available = hal_port_readable(port);
    char* pos;

    hal_port_peek(port, data, available < 32 ? available : 32);

    pos = strchr(data, ';');

    if(!pos) {
        return false;
    }

    *value = strtod(data, &pos);

    if(pos == data) {
        return false;
    }

    hal_port_peek_commit(port, pos - data + 1);

    return true;
}

bool read_uint(hal_port_t port, hal_u32_t* value) {
    char data[10];
    unsigned int available = hal_port_readable(port);
    char* pos;

    hal_port_peek(port, data, available < 10 ? available : 10);

    pos = strchr(data, ';');

    if(!pos) {
        return false;
    }

    *value = strtoul(data, &pos, 10);
    
    if(pos == data) {
        return false;
    }

    hal_port_peek_commit(port, pos - data + 1);

    return true;
}

/*
    reads and consumes a pixel value for the program port. 
    pixel data is encoded as ascii hex values [0-9][A-F] with each character representing 4 bits of data
    pixels bpp must be defined in increments of 4.
*/
bool read_pixel_data(hal_port_t port, unsigned bits_per_pixel, hal_float_t* power) {
    char data[8];
    unsigned int value = 0;
    unsigned int off = 0xFFFFFFFF >> (32 - bits_per_pixel);
    unsigned int bytes_per_pixel = bits_per_pixel / 4;
    char* pos;

    if(!hal_port_read(port, data, bytes_per_pixel)) {
        return false;
    }

    data[bytes_per_pixel] = 0;

    value = strtoul(data, &pos, 16);

    if(data == pos) {
        return false;
    }
    
    /*a value with all 1 bits in the pixel is a special value considered "off" for the raster and no power will be output*/
    if(value == off) {
        *power = -1.0;
    } else {
        *power = 100.0 * ((hal_float_t)value)/((hal_float_t)(off-1));
    }

    return true;
}



bool read_program_begin(hal_port_t port, hal_float_t* offset, hal_u32_t* bits_per_pixel, hal_float_t* pixels_per_unit, hal_u32_t* total_pixel_count) {
    if(!read_float(port, offset)) {
        return false;
    }

    if(!read_uint(port, bits_per_pixel)) {
        return false;
    }

    if((*bits_per_pixel == 0) || (*bits_per_pixel > 32) || ((*bits_per_pixel % 4) != 0)) {
        rtapi_print_msg(RTAPI_MSG_DBG, "RASTER: Bytes per pixel is invalid. Must be between 0 and 32 in increments of 4. Given %u\n", *bits_per_pixel);
        return false;
    }

    if(!read_float(port, pixels_per_unit)) {
        return false;
    }

    if(*pixels_per_unit <= 0.0) {
        rtapi_print_msg(RTAPI_MSG_DBG, "RASTER: Scale per pixel is invalid. Must be greater than 0. Given: %f\n", *pixels_per_unit);
    }

    if(!read_uint(port, total_pixel_count)) {
        return false;
    }

    return true;
}


FUNCTION(_) {
    hal_float_t fraction;

    output = -1.0;
    enabled = 0;

    if (reset) {
        state = PROGRAM_CLEAR;
        hal_port_clear(program);
    } else if (state == PROGRAM_FAULT) {
        fault = 1;
    } else if (state == PROGRAM_CLEAR) {
        state = PROGRAM_BEGIN;
        fault = 0;
        fault_code = ERROR_NONE;
    } else if (state == PROGRAM_BEGIN && (hal_port_readable(program) > 0)) {
        if(!read_program_begin(program, &program_offset, &bpp, &ppu, &pixel_count)) {
            state = PROGRAM_FAULT;
            fault_code = ERROR_INVALID_CMD;
        } else {
            rtapi_print_msg(RTAPI_MSG_DBG, "RASTER: BEGIN. Offset(%f), Pixel Scale(%f), BPP(%d), Pixel Count(%d)\n", program_offset, ppu, bpp, pixel_count);            
            program_position = position;
            current_pixel_index = -1;
            current_pixel_value = -1.0;
            previous_pixel_value = -1.0;
            state = PROGRAM_RUN;
        }
    } else if (state == PROGRAM_RUN) {
        enabled = 1;
        output = -1.0;

        //position in bitmap space of input position
        bitmap_position = (position - (program_position + program_offset)) * ppu * (program_offset < 0.0 ? -1.0 : 1.0);
            
        if(bitmap_position > (pixel_count-1)) {
            state = PROGRAM_CLEAR;
            hal_port_clear(program);
        } else if (bitmap_position < (current_pixel_index - 1)) {
            state = PROGRAM_FAULT;
            fault_code = ERROR_WRONGDIR;
        } else {
            while(bitmap_position > current_pixel_index) {
                current_pixel_index = current_pixel_index+1;
                previous_pixel_value = current_pixel_value;

                if(!read_pixel_data(program, bpp, &current_pixel_value)) {
                    state = PROGRAM_FAULT;
                    fault_code = ERROR_PROGTOOSMALL;
                    return;
                }
            }
        }

        if((current_pixel_value < 0) || (previous_pixel_value < 0)) {
            output = -1;
        } else {
            fraction = bitmap_position - (hal_float_t)(current_pixel_index - 1); 
            output = fraction*(current_pixel_value-previous_pixel_value) + previous_pixel_value;
        }

    }
}

