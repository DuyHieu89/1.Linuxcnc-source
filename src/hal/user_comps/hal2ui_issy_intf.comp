component hal2ui_issy_intf "HAL side of smartserial kbd and smartserial io UI";
//option singleton yes;
option userspace yes;
option userinit yes;

license "GPLv2 or greater";

param rw u32 sleeptime;
pin in u64 sskbd_pin "Smartserial keybord state";
pin out u32 sskbd_led "Smartserial keyboard key leds(47)";
pin in bit inp_pin## [32] "SSIO input pins(32)";
pin out bit out_pin## [32] "SSIO output pins(32)";  
pin in u32 inpi "SSIO iput u32";
pin out u32 outi "SSIO output u32";
;;

#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <sys/socket.h> 
#include <sys/un.h> 
#include <unistd.h> 
#include <signal.h>
#include <fcntl.h> /* Added for the nonblocking socket */


typedef struct {
    uint8_t id;
    uint32_t pins_in;
    uint32_t pins_out;
    uint64_t sskbd_in;
    uint64_t ssdkd_led;
    uint32_t int_inp;
    uint32_t int_out;
} hal2ui;


hal2ui cur_state= { 2,0,0,0L,0L,0,0};
hal2ui old_state= { 2,0,0,0L,0L,0,0};

int client_socket_fd,socket_fd; 
const char* const socket_name ="/tmp/ui_issy"; 
struct sockaddr_un name;  /* Structs for the client and server socket addresses. */


hal2ui buff[1];

unsigned char emc_in_bits[48];
unsigned char emc_out_bits[48];
long int emc_s32s[6];

int should_exit = 0;

void sigterm_handler(int signo) {
    should_exit = 1;
    fprintf(stderr,"end signaled signo:%d\n",signo);
}

int do_read(int fd, void *buffer,ssize_t length)
{
    ssize_t result=0,l=0;
    while (l<length) {
        result = read(fd, buffer+l, length-l);
        if (result <= 0 && errno != EAGAIN) break;
        l+=result;
    };
    if (result == 0) {
        return 1;
    } else if (result < 0) {
        should_exit = 1;    
        return -1;
    };
    return 0;
}

int do_write(int fd, void *buffer,ssize_t length)
{
    ssize_t result,l=0;
    while (l < length) {
        result= write(fd, buffer +l,length -l);
        if (result < 0) {
            if (errno == EAGAIN)
                return 0;
            should_exit = 1;
            return -1;
        }
        l += result;
    }
    return 0;
}

void userinit(int argc, char **argv)
{
     
    signal(SIGTERM, sigterm_handler);
    
    socket_fd = socket (PF_LOCAL, SOCK_STREAM,0); /* Create the socket.   */ 
    /* Indicate that this is a server.   */ 
    unlink( socket_name ); /* Remove any previous socket with the same filename. */
    bzero( &name, sizeof( name ) ); /* Zero all fields of servaddr. */
    name.sun_family = AF_LOCAL; /* Socket type is local (Unix Domain). */
    strcpy (name.sun_path, socket_name); /* Define the name of this socket. */
    bind (socket_fd, (struct sockaddr *)&name, SUN_LEN(&name)); 
    /* Listen for connections.   */ 
    listen (socket_fd, 5);   
}

void user_mainloop(void) 
{
int flags;
int length; 
fd_set readset,writeset;
struct timeval tval = {0,20000};
struct sockaddr_storage ss;
socklen_t slen = sizeof(ss);


    /* Accept a connection.   */ 
    client_socket_fd = accept (socket_fd, (struct sockaddr*)&ss, &slen); 
    if ( client_socket_fd < 0 ) {
        if ( errno != EINTR ) /* Something interrupted us. */
            {
                fprintf( stderr, "Accept Error\n" );
                should_exit = 1;
            };
    };
    flags = fcntl(client_socket_fd, F_GETFL, 0);
     /* Change the socket into non-blocking state	*/
    fcntl(client_socket_fd, F_SETFL, flags|O_NONBLOCK);
    /* Handle the connection.   */
    while(!should_exit) {
        FOR_ALL_INSTS() {
            int r=0;
            FD_ZERO (&readset);
            FD_ZERO (&writeset);
            FD_SET (client_socket_fd, &readset);
            FD_SET (client_socket_fd, &writeset);
            r=select(client_socket_fd+1, &readset, NULL, NULL, &tval);
            if ( r < 0) {
                perror("Err select error");
                continue;
            } else if (r==1 && FD_ISSET(client_socket_fd, &readset)) {
                    r=do_read (client_socket_fd, buff, sizeof (cur_state));
                    if(r!=0) {
                         fprintf(stderr,"Err read socket:%d",r);
                         should_exit = 1;
                    } else {
                        for (int i=0,o=buff->pins_out;i<32;i++) {
                            out_pin(i) = (o & 1)==1;
                            o= o>>1;
                        }
                        outi = buff->int_out;
                    }
            };
            for (int i=0,o=1; i<32; i++){
                    cur_state.pins_in = inp_pin(i) ?
                         cur_state.pins_in | o:
                         cur_state.pins_in & ~o;
                    o<<=1;     
            };
            cur_state.int_inp = inpi;
            if ((old_state.pins_in!=cur_state.pins_in) || (old_state.int_inp!=cur_state.int_inp)) {
                    length = sizeof(cur_state);
                    r=select(client_socket_fd+1, NULL, &writeset, NULL, &tval);
                    if (r==1 && FD_ISSET(client_socket_fd, &writeset)){
                        if(do_write (client_socket_fd,&cur_state,length)) {
                            perror("Err write socket\n");
                            should_exit = 1;
                            continue;
                        };
                    } else if (r<0) {
                        perror("Err sock select");
                    }
                    memcpy(&old_state,&cur_state,length); 
            };
            
        }
        
    }
    /* Close our end of the connection.   */ 
    close (client_socket_fd);
    FD_CLR(client_socket_fd,&readset);
    FD_CLR(client_socket_fd,&writeset);
    close (socket_fd);
    unlink (socket_name); 
}