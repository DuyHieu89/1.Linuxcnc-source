component hal2linsock """
HAL side pin <-> any UI via standard linux sockets
componet is socket server 
default socket name is /tmp/hal2uis
component can take argument named socket_name with your desired soket full path name
""";

option userspace yes;
option userinit yes;

license "GPLv2 or greater";

param rw u32 sleeptime;
pin in bit inp_pin## [32] "HAL input pins(32)";
pin out bit out_pin## [32] "HAL output pins(32)";  
pin in u32 inpi "HAL input 32bit integer";
pin out u32 outi "HAL output 32bit integer";
;;
/*
  Userspace HAL component to control a Hitatchi WJ200 series VFD

  Written by Jasen Kolev, inspired by WJ200_vfd.comp in linuxcnc

  Copyright (C) 2017 Jasen Kolev

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation, version 2.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301-1307  USA.

  see 'man hal2linsock' section in the Drivers manual.
   * 
   * 
   * 
   * demo socket client
   * 
   * 
#include <stdio.h> 
#include <string.h> 
#include <sys/socket.h> 
#include <sys/un.h> 
#include <unistd.h> 
#include <signal.h>
#include <stdint.h>
#include <unistd.h>

typedef struct {
    uint8_t id;
    uint32_t pins_in;
    uint32_t pins_out;
    uint32_t int_inp;
    uint32_t int_out;
} hal2ui;


hal2ui in_state= { 0,0,0,0,0};
hal2ui out_state= { 1,0xffffffff,0xffffffff,0,0};


int should_exit =0;

void sigterm_handler(int signo) {
    should_exit = 1;
}

 
int main (int argc, char* const argv[]) 
{
   const char* const socket_name = "/tmp/hal2uis"; 
   int socket_fd; 
   struct sockaddr_un name; 
   int i=0,b=1;  

   signal(SIGTERM, sigterm_handler);
   // Create the socket.   
   socket_fd = socket (PF_LOCAL, SOCK_STREAM, 0); 
   // Store the server's name in the socket address.  
   name.sun_family = AF_LOCAL; 
   strcpy (name.sun_path, socket_name); 
   // Connect the socket.   
   if (connect(socket_fd,(struct sockaddr *)&name, SUN_LEN(&name)) <0 ) {
       perror("Err socket connect");
       should_exit = 1;
   }
   while (!should_exit) {
      // Write pins to the socket.
      printf("i=%d\t",i);
      out_state.int_out  = i;
      out_state.pins_out ^= b;
      printf("oi=%d\tpins=%#x\n",out_state.int_out,out_state.pins_out);
      if (write(socket_fd, &out_state,sizeof(out_state))<0) {
          should_exit = 0;
          perror("write socket\n");
          continue;
      }
      out_state.pins_out ^= b;
     // read pins 
      if (read(socket_fd,&in_state,sizeof(in_state))<1){
          should_exit = 0;
          perror("Err read socket error\n");
          continue;
      } 
      printf("Input int=%d\n",in_state.int_inp);
      printf("inpins = %#x\n",in_state.pins_in);
    
      i++; b=(1<<i);  
      i &= 0x1f;
   }; 
   close (socket_fd); 
   return 0; 
} 
    *
    *
    * 
 * */
 

#include <stdio.h> 
#include <stdlib.h> 
#include <getopt.h>
#include <string.h> 
#include <sys/socket.h> 
#include <sys/un.h> 
#include <unistd.h> 
#include <signal.h>
#include <fcntl.h> /* Added for the nonblocking socket */


typedef struct {
    uint8_t id;
    uint32_t pins_in;
    uint32_t pins_out;
    uint32_t int_inp;
    uint32_t int_out;
} hal2ui; /* socket comunication structure */


hal2ui cur_state= { 2,0,0,0,0};
hal2ui old_state= { 2,0,0,0,0};

int client_socket_fd,socket_fd; 
const char* socket_name ="/tmp/hal2uis"; 
struct sockaddr_un name;  /* Structs for the client and server socket addresses. */


hal2ui buff[1];

unsigned char emc_in_bits[48];
unsigned char emc_out_bits[48];
long int emc_s32s[6];

int should_exit = 0;

void sigterm_handler(int signo) {
    should_exit = 1;
    fprintf(stderr,"end signaled signo:%d\n",signo);
}

int do_read(int fd, void *buffer,ssize_t length)
{
    ssize_t result=0,l=0;
    while (l<length) {
        result = read(fd, buffer+l, length-l);
        if (result <= 0 && errno != EAGAIN) break;
        l+=result;
    };
    if (result == 0) {
        return 1;
    } else if (result < 0) {
        should_exit = 1;    
        return -1;
    };
    return 0;
}

int do_write(int fd, void *buffer,ssize_t length)
{
    ssize_t result,l=0;
    while (l < length) {
        result= write(fd, buffer +l,length -l);
        if (result < 0) {
            if (errno == EAGAIN)
                return 0;
            should_exit = 1;
            return -1;
        }
        l += result;
    }
    return 0;
}

void userinit(int argc, char **argv)
{
   	int opt_index = 0;
	int c = 0;
    static struct option options[] = {
		{"socket_name", required_argument, 0, 0 },
		{0, 0, 0, 0}
	};	

	c = getopt_long(argc, argv, "", options, &opt_index);
    
	if ((c != -1)&& (opt_index==1)) socket_name = optarg;
    
    signal(SIGTERM, sigterm_handler);
    
    socket_fd = socket (PF_LOCAL, SOCK_STREAM,0); /* Create the socket.   */ 
    /* Indicate that this is a server.   */ 
    unlink( socket_name ); /* Remove any previous socket with the same filename. */
    bzero( &name, sizeof( name ) ); /* Zero all fields of servaddr. */
    name.sun_family = AF_LOCAL; /* Socket type is local (Unix Domain). */
    strcpy (name.sun_path, socket_name); /* Define the name of this socket. */
    bind (socket_fd, (struct sockaddr *)&name, SUN_LEN(&name)); 
    /* Listen for connections.   */ 
    listen (socket_fd, 5);   
}

void user_mainloop(void) 
{
int flags;
int length; 
fd_set readset,writeset;
struct timeval tval = {0,20000};
struct sockaddr_storage ss;
socklen_t slen = sizeof(ss);


    /* Accept a connection.   */ 
    client_socket_fd = accept (socket_fd, (struct sockaddr*)&ss, &slen); 
    if ( client_socket_fd < 0 ) {
        if ( errno != EINTR ) /* Something interrupted us. */
            {
                fprintf( stderr, "Accept Error\n" );
                should_exit = 1;
            };
    };
    flags = fcntl(client_socket_fd, F_GETFL, 0);
     /* Change the socket into non-blocking state	*/
    fcntl(client_socket_fd, F_SETFL, flags|O_NONBLOCK);
    /* Handle the connection.   */
    while(!should_exit) {
        FOR_ALL_INSTS() {
            int r=0;
            FD_ZERO (&readset);
            FD_ZERO (&writeset);
            FD_SET (client_socket_fd, &readset);
            FD_SET (client_socket_fd, &writeset);
            r=select(client_socket_fd+1, &readset, NULL, NULL, &tval);
            if ( r < 0) {
                perror("Err select error");
                continue;
            } else if (r==1 && FD_ISSET(client_socket_fd, &readset)) {
                    r=do_read (client_socket_fd, buff, sizeof (cur_state));
                    if(r!=0) {
                         fprintf(stderr,"Err read socket:%d",r);
                         should_exit = 1;
                    } else {
                        for (int i=0,o=buff->pins_out;i<32;i++) {
                            out_pin(i) = (o & 1)==1;
                            o= o>>1;
                        }
                        outi = buff->int_out;
                    }
            };
            for (int i=0,o=1; i<32; i++){
                    cur_state.pins_in = inp_pin(i) ?
                         cur_state.pins_in | o:
                         cur_state.pins_in & ~o;
                    o<<=1;     
            };
            cur_state.int_inp = inpi;
            if ((old_state.pins_in!=cur_state.pins_in) || (old_state.int_inp!=cur_state.int_inp)) {
                    length = sizeof(cur_state);
                    r=select(client_socket_fd+1, NULL, &writeset, NULL, &tval);
                    if (r==1 && FD_ISSET(client_socket_fd, &writeset)){
                        if(do_write (client_socket_fd,&cur_state,length)) {
                            perror("Err write socket\n");
                            should_exit = 1;
                            continue;
                        };
                    } else if (r<0) {
                        perror("Err sock select");
                    }
                    memcpy(&old_state,&cur_state,length); 
            };
            
        }
        
    }
    /* Close our end of the connection.   */ 
    close (client_socket_fd);
    FD_CLR(client_socket_fd,&readset);
    FD_CLR(client_socket_fd,&writeset);
    close (socket_fd);
    unlink (socket_name); 
}