component wj200_vfd "Hitachi wj200 modbus driver";
param rw unsigned mbslaveaddr     "Modbus slave address";
pin in float commanded_frequency  "Frequency of vfd";
pin in bit reverse                "1 when reverse 0 when forward";
pin in bit run                    "run the vfd";
pin in bit enable                 "1 to enable the vfd. 0 will remote trip the vfd, thereby disabling it.";
pin out bit is_running            "1 when running";
pin out bit is_at_speed           "1 when running at assigned frequency";
pin out bit is_ready              "1 when vfd is ready to run";
pin out bit is_alarm              "1 when vfd alarm is set";
pin out float motor_current       "Output current in amps";
pin out float heatsink_temp       "Temperature of drive heatsink";
pin out bit watchdog_out          "Alternates between 1 and 0 after every update cycle. Feed into a watchdog component to ensure vfd driver is communicating with the vfd properly.";
option userspace;
option userinit yes;
license "GPLv2 or greater";
;;
/*
  Userspace HAL component to control a Hitatchi WJ200 series VFD

  Written by Curtis Dutton, inspired by vfs11_vfd.c in linuxcnc

  Copyright (C) 2012 Curtis Dutton, OK Computers LLC

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation, version 2.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301-1307  USA.

  see 'man wj200_vfd' and the WJ200 section in the Drivers manual.
*/
#include<stdio.h>
#include<errno.h>
#include<getopt.h>
#include<stdbool.h>
#include<math.h>
#include<modbus.h>
#include<unistd.h>
#include<ctype.h>

typedef struct
{
        uint8_t running;
        uint8_t ready;
        uint8_t direction;
        uint8_t at_speed;
        uint8_t alarm;
	float output_current;
	float sink_temp;
        uint16_t frequency;
} wj200_status;

/*sets the operating frequency of the vfd*/
bool wj200_setFrequency(modbus_t* ctx, uint16_t frequency)
{
        return modbus_write_registers(ctx, 0x001, 1, &frequency) > 0;
}

/*resets the trip status of the VFD*/
bool wj200_reset(modbus_t* ctx)
{
        /*after the reset, the wj200 vfd seem to need a second
        before it will reply to more modbus commands*/
        int rc = modbus_write_bit(ctx, 0x003, TRUE);

        sleep(1);

        return rc > 0;
}

bool wj200_setDirection(modbus_t* ctx, bool direction)
{
	return modbus_write_bit(ctx, 0x001, direction) > 0;
}

bool wj200_trip(modbus_t* ctx)
{
        return modbus_write_bit(ctx, 0x002, TRUE) > 0;
}

bool wj200_run(modbus_t* ctx, bool runBit)
{
        return modbus_write_bit(ctx, 0x000, runBit) > 0;
}


bool wj200_getStatus(modbus_t* ctx, wj200_status* status)
{
        int rc;
        uint8_t bits[16];
        uint16_t registers[2];
	    uint16_t currentRegister[1];
	    uint16_t temperatureRegister[1];

        /*read coils 0x000F thru 0x0019 in one step*/
        rc = modbus_read_bits(ctx, 0x000F-1, 11, bits);

        if(rc < 0)
        {
                return false;
        }

        /*read the first 2 registers*/
        rc = modbus_read_registers(ctx, 0x000, 2, registers);

        if(rc < 0)
        {
                return false;
        }

	// Read 1003h (output current) to 1019h (heatsink temp)
        rc = modbus_read_registers(ctx, 0x1003-1, 1, currentRegister);

        if(rc < 0)
        {
                return false;
        }

	rc = modbus_read_registers(ctx, 0x1019-1, 1, temperatureRegister);

        if(rc < 0)
        {
                return false;
        }


        status->running = bits[0];
        status->direction = bits[1];
        status->ready = bits[2];
        status->alarm = bits[9];
        status->at_speed = bits[5];
        status->frequency = registers[1];
	status->output_current = currentRegister[0];
	status->sink_temp = temperatureRegister[0];

        return true;
}

void print_modbus_error(struct __comp_state *__comp_inst, const char* msg)
{
	fprintf(stderr, 
		"Error: wj200_vfd slave(%d): %s - Modbus error (%d) -  %s\n",
		mbslaveaddr,
		msg,
		errno,
		modbus_strerror(errno));
}

void usage(int argc, char **argv) {
    printf("Usage:  %s [options]\n", argv[0]);
    printf("This is a userspace HAL program, typically loaded using the halcmd \"loadusr\" command:\n"
            "    loadusr wj200_vfd [options]\n"
            "Options are:\n"
            "-b or --baud <n> (default 9600)\n"
	    "    Set baud rate to <n>.  It is an error if the rate is not one of the following:\n"
	    "    9600, 19200, 38400, 57600, 115200\n"
	    "-p or --parity {E,O,N} (default N)\n"
            "    Set serial parity to even, odd, or none.\n"
            "-a or --data <n> (default 8)\n"
	    "    Set number of data bits to <n>, where n must be from 5 to 8 inclusive\n"
	    "-s or --stop {1,2} (default 1)\n"
	    "    Set serial stop bits to 1 or 2\n"
            "-d or --device <path> (default /dev/ttyS0)\n"
	    "    Set the name of the serial device node to use\n"
	    "\nExample:\n"
	    "    loadusr -W wj200_vfd --device /dev/ttyUSB0 --baud 9600 --parity N --data 8 --stop 1\n"
	    "    loadusr -W wj200_vfd -d /dev/ttyUSB0 -a 9600 --parity N --data 8 --stop 1\n\n"
	    );
}

/* modbus connection settings*/
char *device = "/dev/ttyS0";
int baud = 9600;
char parity = 'N';
int data_bits = 8;
int stop_bits = 1;
modbus_t *ctx;

void userinit(int argc, char **argv)
{
	int opt_index = 0;
	int opt = 0;

	static char *option_string = "b:p:a:s:d:";
        static struct option options[] = {
		{"baud",   required_argument, 0, 'b' },
		{"parity", required_argument, 0, 'p' },
		{"databits", required_argument, 0, 'a' },
		{"stopbits", required_argument, 0, 's' },
		{"device", required_argument, 0, 'd' },
		{0, 0, 0, 0}
	};	

	while ((opt = getopt_long(argc, argv, option_string, options, &opt_index)) != -1) {
    
		switch(opt) {
			
			case 'b':
			
				baud = atoi(optarg);

				if(baud == 0)
				{
					fprintf(stderr, 
						"Invalid argument: baud must be a number. Given '%s'\n", 
						optarg);
					exit(1);
				}
                                printf("wj200_vfd: baud set to %d\n", baud);
				break;

			case 'p':
				parity = toupper(optarg[0]);

				if(parity != 'O' && parity != 'N' && parity != 'E')
				{
					fprintf(stderr, 
						"Invalid argument: parity must be 'o' or 'e' or 'n'. Given '%s'\n", 
						optarg);
					exit(1);
				}

                                printf("wj200_vfd: parity set to %c\n", parity);
				break;

			case 'a':
				data_bits = atoi(optarg);

				if(data_bits == 0)
				{
					fprintf(stderr, 
						"Invalid argument: databits must be a number. Given '%s'\n", 
						optarg);
					exit(1);
				}
                                printf("wj200_vfd: databits set to %d\n", data_bits);
				break;

			case 's':
				stop_bits = atoi(optarg);
		
				if(stop_bits == 0)
				{
					fprintf(stderr, 
						"Invalid argument: stopbits must be a number. Given '%s'\n", 
						optarg);
					exit(1);
				}
                                printf("wj200_vfd: stopbits set to %d\n", stop_bits);
				break;
			case 'd':
				device = optarg;
                                printf("wj200_vfd: device set to %s\n", device);
				break;


			default:
                                fprintf(stderr, "WARNING: invalid option index!\n");
                                usage(argc, argv);
				exit(1);
		}

	}

        if (optind < argc) {
            fprintf(stderr, "WARNING: unhandled arguments to wj200_vfd driver:\n");
            for (int i = optind; i < argc; i ++) {
                fprintf(stderr, "    %s\n", argv[i]);
            }
            usage(argc, argv);
        }

        printf("wj200_vfd: current settings - device=%s, baud=%d, parity=%c, data=%d, stop=%d\n", device, baud, parity, data_bits, stop_bits);
	ctx = modbus_new_rtu(device, baud, parity, data_bits, stop_bits);

	if (ctx == NULL) {
		fprintf(stderr, 
			"ERROR: wj200_vfd unable to create libmodbus context. - %s\n", 
			modbus_strerror(errno));
		fprintf(stderr, "Check your commandline!\n");
		exit(1);	
	}
	
	if (modbus_connect(ctx)) {
		fprintf(stderr, 
			"ERROR: wj200_vfd unable to create libmodbus connection. - %s\n", 
			modbus_strerror(errno));
		exit(1);
	}
}

void user_mainloop(void) {
	wj200_status status;
	uint16_t calculated_frequency;

	while(1) {
	FOR_ALL_INSTS() {
		/*
                  until the params are set we just wait a bit
		  and then skip to the next instance.

		  if every instance does not get a slave address,
                  this could cause bad behavior
		*/
		if(mbslaveaddr == 0) {
			sleep(1);
			continue; 
		}

		modbus_set_slave(ctx, mbslaveaddr);

		/*
                  for each slave, receive info from the slave,
		  update our output pins based upon vfd status,
		  then set the vfd according to our input pins

		  if we hit an error we just re-loop. The watchdog
		  pin won't change until we make it all the way through
		  the loop.
                */
		if(!wj200_getStatus(ctx, &status)) {	
			print_modbus_error(__comp_inst, "failed to get status");
			continue;
		}

		is_running = status.running;
		is_at_speed = status.at_speed;
		is_ready = status.ready;
		is_alarm = status.alarm;

		if(!status.alarm && !enable && !wj200_trip(ctx)) {
			print_modbus_error(__comp_inst, "failed to trip");
			continue;
		}
		else if(status.alarm && enable && !wj200_reset(ctx)) {
			print_modbus_error(__comp_inst, "failed to reset");
			continue;
		}
		else {
			calculated_frequency = (uint16_t)(fabs(commanded_frequency) * 100);

			if(calculated_frequency != status.frequency 
			   && !wj200_setFrequency(ctx, calculated_frequency)) {
				print_modbus_error(__comp_inst, "failed to set frequency");
				continue;
			}

			if(reverse != status.direction && !wj200_setDirection(ctx, reverse)) {
				print_modbus_error(__comp_inst, "failed to set direction");
				continue;
			}

			if(status.running ^ run && !wj200_run(ctx, run)) {
				print_modbus_error(__comp_inst, "failed to run");
				continue;
			}

			watchdog_out = !watchdog_out;
			motor_current = status.output_current / 100;
			heatsink_temp = status.sink_temp / 10;
		}
	}
	}
}
